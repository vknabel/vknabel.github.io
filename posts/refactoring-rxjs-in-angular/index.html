<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Refactoring RxJS Code in Angular - vknabel</title><link rel=icon type=image/png href=/images/vknabel.jpg><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Do you work with legacy RxJS code? Have you ever revisited your first few observables in your application? Do you need to fix bugs in an app of your learning phase? Are you still learning best practices for writing reactive code? This guide is for you. Even if you don’t have anything to do with Angular, you may find this interesting. I will show you a way of how to improve your reactive streams in order to understand their functionality in many isolated, but tiny steps. Some of them may offer external dependencies, but we will always show, how to do it manually."><meta property="og:image" content><meta property="og:url" content="https://vknabel.com/posts/refactoring-rxjs-in-angular/"><meta property="og:site_name" content="vknabel"><meta property="og:title" content="Refactoring RxJS Code in Angular"><meta property="og:description" content="Do you work with legacy RxJS code? Have you ever revisited your first few observables in your application? Do you need to fix bugs in an app of your learning phase? Are you still learning best practices for writing reactive code? This guide is for you. Even if you don’t have anything to do with Angular, you may find this interesting. I will show you a way of how to improve your reactive streams in order to understand their functionality in many isolated, but tiny steps. Some of them may offer external dependencies, but we will always show, how to do it manually."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-09-28T00:00:00+00:00"><meta property="article:modified_time" content="2017-09-28T00:00:00+00:00"><meta property="article:tag" content="Web"><meta property="article:tag" content="Functional"><meta property="article:tag" content="Migration"><meta name=twitter:card content="summary"><meta name=twitter:title content="Refactoring RxJS Code in Angular"><meta name=twitter:description content="Do you work with legacy RxJS code? Have you ever revisited your first few observables in your application? Do you need to fix bugs in an app of your learning phase? Are you still learning best practices for writing reactive code? This guide is for you. Even if you don’t have anything to do with Angular, you may find this interesting. I will show you a way of how to improve your reactive streams in order to understand their functionality in many isolated, but tiny steps. Some of them may offer external dependencies, but we will always show, how to do it manually."><script src=https://vknabel.com/js/feather.min.js></script><link href=https://vknabel.com/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://vknabel.com/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://vknabel.com/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css media="(prefers-color-scheme: dark)"><link rel=stylesheet type=text/css href=/css/overrides.css></head><body><div class=content><header><div class=main><a href=https://vknabel.com/>vknabel</a></div><nav><a href=/>blog</a>
<a href=/tils>tils</a>
<a href=/about>about</a>
<a href=/tags>tags</a></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Refactoring RxJS Code in Angular</h1><div class=meta>Posted on Sep 28, 2017</div></div><section class=body><p>Do you work with legacy RxJS code? Have you ever revisited your first few observables in your application? Do you need to fix bugs in an app of your learning phase? Are you still learning best practices for writing reactive code? This guide is for you. Even if you don’t have anything to do with Angular, you may find this interesting. I will show you a way of how to improve your reactive streams in order to understand their functionality in many isolated, but tiny steps. Some of them may offer external dependencies, but we will always show, how to do it manually.</p><p>Within each step we isolate/eliminate side effects, get more explicit about lifetime and learn about how to prevent unintended behavior. If you use this guide to refactor some specific code, you should perform all single steps in order and rerun all tests after each change. If you can‘t find the shown pattern you can take the next step.</p><blockquote><p><em>Unit Testing:</em> If you don‘t have any test create them upfront. Each step is a small refactoring: you may break something. For the guys of you who sit in front of really untestable code: I understand your situation. All ”dangerous” steps are marked. You need to test much more and manually. At least introduce unit tests afterwards. Dependency injection is your friend.</p></blockquote><p>In the beginning, we start easy and just isolate our side effects from our subscriptions. Instead of passing our callbacks directly, we wrap them into <code>do</code> operators. Whenever you read a <code>do</code>, you know: that‘s a side effect.
If you want a slightly more expressive variant try <code>@molecule/do-next</code>, <code>@molecule/do-error</code> and <code>@molecule/do-complete</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// previous code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myObservable$</span>.<span style=color:#a6e22e>subscribe</span>(
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>next</span>) =&gt; <span style=color:#a6e22e>handleNext</span>(<span style=color:#a6e22e>next</span>),
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>error</span>) =&gt; <span style=color:#a6e22e>handleError</span>(<span style=color:#a6e22e>error</span>),
</span></span><span style=display:flex><span>  () =&gt; <span style=color:#a6e22e>handleCompletion</span>()
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// refactored code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myObservable$</span>
</span></span><span style=display:flex><span>  .<span style=color:#66d9ef>do</span>(
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>next</span>) =&gt; <span style=color:#a6e22e>handleNext</span>(<span style=color:#a6e22e>next</span>),
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>error</span>) =&gt; <span style=color:#a6e22e>handleError</span>(<span style=color:#a6e22e>error</span>),
</span></span><span style=display:flex><span>    () =&gt; <span style=color:#a6e22e>handleCompletion</span>()
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>subscribe</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* or with @molecule/do-next,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @molecule/do-error,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @molecule/do-complete
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>myObservable$</span>
</span></span><span style=display:flex><span>  .<span style=color:#66d9ef>do</span>(
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>next</span>) =&gt; <span style=color:#a6e22e>handleNext</span>(<span style=color:#a6e22e>next</span>),
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>error</span>) =&gt; <span style=color:#a6e22e>handleError</span>(<span style=color:#a6e22e>error</span>),
</span></span><span style=display:flex><span>    () =&gt; <span style=color:#a6e22e>handleCompletion</span>()
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>subscribe</span>()
</span></span></code></pre></div><p>Well, that was easy. Now let‘s make all of our operators simpler. A good sign, that you tried to do more than one thing inside an operator is the use of closure blocks and explicit return statements (<code>() => {}</code>).
Especially if we extract all side effects from our operators, we know: <em>all</em> side effects live within <code>do*</code> and <code>finally</code>!
Every statement that is not your <code>return</code>-statement and no variable declaration, that is used for your <code>return</code> is a side effect. If the operator is a <code>catch</code>, move the side effects logically isolated (see above) to <code>do(undefined, yourErrorHandler)</code>/<code>doError(yourErrorHandler)</code>. Otherwise extract them to <code>do</code>/<code>doNext</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// previous code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myObservable$</span>.<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>error</span> =&gt; {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#960050;background-color:#1e0010>’</span><span style=color:#a6e22e>Could</span> <span style=color:#a6e22e>not</span> <span style=color:#a6e22e>resolve</span> <span style=color:#a6e22e>myObservable$</span><span style=color:#960050;background-color:#1e0010>’</span>, <span style=color:#a6e22e>error</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Observable</span>.<span style=color:#a6e22e>empty</span>();
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#75715e>// refactored code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myObservable$</span>
</span></span><span style=display:flex><span>	 <span style=color:#75715e>// or use .do(undefined, errorHandler)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  .<span style=color:#a6e22e>doError</span>(<span style=color:#a6e22e>error</span> =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(
</span></span><span style=display:flex><span>		<span style=color:#960050;background-color:#1e0010>’</span><span style=color:#a6e22e>Could</span> <span style=color:#a6e22e>not</span> <span style=color:#a6e22e>resolve</span> <span style=color:#a6e22e>myObservable$</span><span style=color:#960050;background-color:#1e0010>’</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>error</span>
</span></span><span style=display:flex><span>	))
</span></span><span style=display:flex><span>  .<span style=color:#66d9ef>catch</span>(() =&gt; <span style=color:#a6e22e>Observable</span>.<span style=color:#a6e22e>empty</span>());
</span></span></code></pre></div><p>In order to further simplify your operation handler, you can extract the whole block into a new <code>private</code> method of your class. If it doesn’t even depend on <code>this</code> you can actually make it <code>static</code>. The following case may seem a bit awkward at first, but it will keep everything simple and stupid. You will see, one can totally understand <code>previewOfFavorites$</code> without knowing all those details. And if the underlying API changes, our public methods with all of our business logic just don‘t care.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// previous code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>previewOfFavorites</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Favorite</span>[]<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>previewSize$</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>settings$</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>settings</span> =&gt; <span style=color:#a6e22e>settings</span>.<span style=color:#a6e22e>preview</span>.<span style=color:#a6e22e>size</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>favorites$</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>favorites$</span>();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Observable</span>.<span style=color:#a6e22e>combineLatest</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>previewSize$</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>previewOfFavorites$</span>,
</span></span><span style=display:flex><span>		(<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>favorites</span>) =&gt; <span style=color:#a6e22e>favorites</span>.<span style=color:#a6e22e>slice</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// refactored code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>previewOfFavorites$</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Favorite</span>[]<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Observable</span>.<span style=color:#a6e22e>combineLatest</span>(
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>previewSize$</span>,
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>previewOfFavorites$</span>,
</span></span><span style=display:flex><span>		(<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>favorites</span>) =&gt; <span style=color:#a6e22e>favorites</span>.<span style=color:#a6e22e>slice</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>previewSize$</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>number</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>settings$</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>settings</span> =&gt; <span style=color:#a6e22e>settings</span>.<span style=color:#a6e22e>preview</span>.<span style=color:#a6e22e>size</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>favorites$</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Favorite</span>[]<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>favorites$</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally we should have mostly single <code>return</code>-statements as handlers and transformations. In that case we just use the short notation for closures. One exception are object literals, which need to be wrapped in parentheses (<code>() => ({})</code>) or leave the explicit return statement if you prefer it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// previous code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myObservable$</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>value</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>value</span>]
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#75715e>// refactored code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myObservable$</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>value</span>) =&gt; [<span style=color:#a6e22e>value</span>])
</span></span></code></pre></div><h2 id=whats-next>What&rsquo;s next?</h2><p>This blogpost has never been finished. It wasn&rsquo;t touch for more than a year and I don&rsquo;t understand all my remaining notes anymore.
Here they are:</p><ul><li><p>Replace instance variables through Observables they represent</p><ul><li>Store observable as <code>readonly</code> and <code>shareReplay(1)</code> and remove <code>subscribe</code>.</li><li>Replace usages with <code>withLatestFrom</code> or <code>this.xx$.first().mergeMap</code></li><li>When filtered procedural, move logic into observable method for later use</li><li>Keep visibility (prefer <code>private</code>, of course)</li><li>Angular templates should use <code>|async</code></li><li>You can now remove <code>changeDetector.markForCheck()</code> invocations</li><li>If param is requires synchronously use <code>Observable.defer().shareReplay(1)</code></li></ul></li><li><p>Remove temporary observable and adjust <code>mergeMap</code>s</p></li><li><p>If extracted subject with object for parameter, adjust function parameters</p></li><li><p>Trigger actions with temporary observable named <code>*Action</code> (<code>Observable.empty().finally</code>)</p></li><li><p>Sideeffect at the begginning before current operator, otherwise behind</p></li><li><p>Keep functions which prevent execution</p></li><li><p>All subjects should always be private: add accessors <code>processDidChange</code>, <code>processDidFail</code>, <code>processDidComplete</code>,<code>processObserver</code> (just if required)</p></li></ul></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/web>web</a></li><li><a href=/tags/functional>functional</a></li><li><a href=/tags/migration>migration</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/vknabel rel=me title=GitHub><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://mastodon.social/@vknabel/ rel=me title=Mastodon><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#at-sign"/></svg></a><a class=border></a></div><div class=footer-info>2025 © Valentin Knabel | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>