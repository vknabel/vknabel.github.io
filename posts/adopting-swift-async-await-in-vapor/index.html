<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Adopting Swift Async Await in Vapor - vknabel</title><link rel=icon type=image/png href=/images/vknabel.jpg><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A few months ago Swift 5.5 has been released and made async/await available. And in 4.50.0 Vapor added support for it, too!

If you are still on Vapor 3, you first need to upgrade your server to Vapor 4.
Now we can migrate most usages of Swift NIO&rsquo;s EventLoopFuture with async. But we don&rsquo;t have to! This is not a breaking change. I recently performed this upgrade for the server of my app Puffery and as both, the client and the server are open source I will include links to the respective git commits."><meta property="og:image" content><meta property="og:url" content="https://vknabel.com/posts/adopting-swift-async-await-in-vapor/"><meta property="og:site_name" content="vknabel"><meta property="og:title" content="Adopting Swift Async Await in Vapor"><meta property="og:description" content="A few months ago Swift 5.5 has been released and made async/await available. And in 4.50.0 Vapor added support for it, too!
If you are still on Vapor 3, you first need to upgrade your server to Vapor 4.
Now we can migrate most usages of Swift NIO’s EventLoopFuture with async. But we don’t have to! This is not a breaking change. I recently performed this upgrade for the server of my app Puffery and as both, the client and the server are open source I will include links to the respective git commits."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-15T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-15T00:00:00+00:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Vapor"><meta property="article:tag" content="Migration"><meta name=twitter:card content="summary"><meta name=twitter:title content="Adopting Swift Async Await in Vapor"><meta name=twitter:description content="A few months ago Swift 5.5 has been released and made async/await available. And in 4.50.0 Vapor added support for it, too!
If you are still on Vapor 3, you first need to upgrade your server to Vapor 4.
Now we can migrate most usages of Swift NIO’s EventLoopFuture with async. But we don’t have to! This is not a breaking change. I recently performed this upgrade for the server of my app Puffery and as both, the client and the server are open source I will include links to the respective git commits."><script src=https://vknabel.com/js/feather.min.js></script><link href=https://vknabel.com/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://vknabel.com/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://vknabel.com/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css media="(prefers-color-scheme: dark)"><link rel=stylesheet type=text/css href=/css/overrides.css></head><body><div class=content><header><div class=main><a href=https://vknabel.com/>vknabel</a></div><nav><a href=/>blog</a>
<a href=/tils>tils</a>
<a href=/about>about</a>
<a href=/tags>tags</a></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Adopting Swift Async Await in Vapor</h1><div class=meta>Posted on Nov 15, 2021</div></div><section class=body><p>A few months ago Swift 5.5 has been released and made <code>async</code>/<code>await</code> available. And in <a href=https://github.com/vapor/vapor/releases/tag/4.50.0>4.50.0</a> Vapor added support for it, too!</p><blockquote><p><em>If you are still on Vapor 3, you first need to <a href=https://www.vknabel.com/pages/Upgrading-a-server-side-Swift-project-to-Vapor-4/>upgrade your server to Vapor 4</a>.</em></p></blockquote><p>Now we can migrate most usages of Swift NIO&rsquo;s <code>EventLoopFuture</code> with <code>async</code>. But we don&rsquo;t have to! This is not a breaking change. I recently performed this upgrade for the server of my app <a href=https://github.com/vknabel/puffery>Puffery</a> and as both, the client and the server are open source I will include links to the respective git commits.</p><blockquote><p><em><strong>Puffery</strong> is an app to send messages into channels using Shortcuts or HTTP. This will trigger a push notification to all clients that have subscribed. Within the app you can view your messages and channels.</em></p></blockquote><p>I wouldn&rsquo;t recommend to directly replace all occurrences of <code>EventLoopFuture</code>. If you aren&rsquo;t going to touch specific code paths in a while, there is no need to migrate those. But we&rsquo;ll come back to that later.</p><h2 id=upgrading-to-swift-55>Upgrading to Swift 5.5</h2><p>If you haven&rsquo;t already, you need to upgrade your Swift Tools Version within your <code>Package.swift</code>-manifest:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// swift-tools-version:5.5</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>PackageDescription</span>
</span></span></code></pre></div><p>Now a few lines later we need to upgrade to a newer macOS version, because <code>async</code>/<code>await</code> not only requires Swift 5.5, but also macOS 12 Monterey. Make sure you have upgraded accordingly. Otherwise you&rsquo;d need to work on a linux machine or within a docker container.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> package = Package(
</span></span><span style=display:flex><span>    name: <span style=color:#e6db74>&#34;PufferyServer&#34;</span>,
</span></span><span style=display:flex><span>    platforms: [
</span></span><span style=display:flex><span>        .macOS(.v12), <span style=color:#75715e>// upgrade to .v12</span>
</span></span><span style=display:flex><span>    ],
</span></span></code></pre></div><p>Next up, we need to bump our dependencies. As we want to rely on special features of the new Vapor, we explicitly go <code>from: "4.50.0"</code>. Repeat this with other dependencies like Fluent.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>		<span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    dependencies: [
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>	    .package(url: <span style=color:#e6db74>&#34;https://github.com/vapor/vapor.git&#34;</span>, from: <span style=color:#e6db74>&#34;4.50.0&#34;</span>), <span style=color:#75715e>// upgrade to 4.50.0</span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>		],
</span></span></code></pre></div><p>Now, to silence a warning, we need to explicitly declare our <code>Run</code> target as <code>executableTarget</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>    targets: [
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>	    .executableTarget(name: <span style=color:#e6db74>&#34;Run&#34;</span>, dependencies: [<span style=color:#e6db74>&#34;App&#34;</span>]),
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>		]
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>If you use a Dockerfile, build <code>FROM swift:5.5 as build</code>. Also if present don&rsquo;t forget to update your <code>.swift-version</code>-file and your CI.</p><p>Now update your packages using <code>swift package update</code>. If you use Xcode, also update your dependencies using <code>File > Packages > Update to Latest Package Versions</code> to keep them in sync. In theory <code>swift build</code> and <code>swift test</code> should run without any errors. If it does, fix those and proceed.</p><p><em><a href=https://github.com/vknabel/puffery/commit/1c41e5ae5c49748c1389b4491e03d595e5b0f406><code>git commit -am "Upgraded PufferyServer to Swift 5.5"</code></a></em></p><h2 id=adopting-async-await>Adopting Async Await</h2><p>Now that we upgraded our new Swift version and updated our dependencies, let&rsquo;s get started with our migration.</p><p>We will incrementally do tiny steps and migrate every function after another. But it doesn&rsquo;t make sense to migrate all functions immediately. If you haven&rsquo;t touched specific files in a while, there is no need to do so now. A great example are your database migrations. You won&rsquo;t touch them anyways. Just write new ones with <code>async</code>/<code>await</code> and you are fine.</p><p>In my opinion, controllers are the easiest place to get started. Later you can tackle migrate <code>Jobs</code> or <code>ScheduledJob</code>s. Then your services and your repositories.</p><p>The easiest places to upgrade will most likely be your Fluent queries: there are overloads for <code>.find()</code> and <code>.all()</code> to return <code>EventLoopFuture</code> and <code>async throws</code>.</p><h3 id=migrate-the-function-signature>Migrate the function signature</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>- 	func messagesForAllChannels(_ req: Request) throws -&gt; EventLoopFuture&lt;[MessageResponse]&gt; {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+ 	func messagesForAllChannels(_ req: Request) async throws -&gt; [MessageResponse] {
</span></span></span></code></pre></div><p>Now fix all issues within the function. Then fix the errors of all callers.</p><p>If you temporarily converted invocations of this method from <code>EventLoopFuture</code> to an async function using <code>.get()</code>, it is now time to remove it.</p><h3 id=migrate-protocol-methods-if-directly-affected>Migrate Protocol Methods if directly affected</h3><p>Most protocols need to be prefixed with <code>Async</code> like <code>AsyncJob</code> or <code>AsyncScheduledJob</code>. Then you can replace all function signatures.</p><h3 id=i-need-async-but-i-have-an-eventloopfuture>I need async, but I have an EventLoopFuture</h3><p>To convert a not yet converted <code>EventLoopFuture</code>, we call <code>EventLoopFuture&lt;V>.get() async throws -> V</code>. You can migrate the function later.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>try</span> await theEventLoopFuture.<span style=color:#66d9ef>get</span>()
</span></span></code></pre></div><h3 id=i-need-an-eventloopfuture-but-i-have-an-async-function>I need an EventLoopFuture, but I have an async function</h3><p>Sometimes I decided to keep some function signatures as they were and I did not migrate them. For those cases I created a small helper function to create an <code>EventLoopFuture</code> from an async task.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>EventLoop</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>from</span>&lt;T&gt;(task: @escaping () async <span style=color:#66d9ef>throws</span> -&gt; T) -&gt; EventLoopFuture&lt;T&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> promise = makePromise(of: T.<span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>        promise.completeWithTask { <span style=color:#66d9ef>try</span> await task() }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> promise.futureResult
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For example executing multiple futures in parallel is easy with <code>eventLoop.flatten</code>, but it&rsquo;s much harder with <code>async</code>/<code>await</code>.</p><h3 id=migrate-flatmap>Migrate <code>.flatMap</code></h3><p>Migrate <code>.flatMap({ messages in doSomething(messages) })</code> to <code>let result = try await doSomething(messages).get()</code>.</p><h3 id=migrate-flatmapthrowing>Migrate <code>.flatMapThrowing</code></h3><p>Migrate <code>.flatMapThrowing({ messages in doSomething(messages) })</code> to <code>let result = try doSomething(messages)</code></p><h3 id=migrate-eventloopflatten>Migrate <code>eventLoop.flatten</code></h3><p>Executing multiple futures in parallel is easy with <code>eventLoop.flatten</code>, but it&rsquo;s much harder with <code>async</code>/<code>await</code>.</p><p>I&rsquo;d recommend to keep this part as is, and to keep this part as <code>EventLoopFuture</code>.
See [I need an EventLoopFuture, but I have async](#I need an EventLoopFuture, but I have async).</p><h3 id=migrate-transformto>Migrate <code>.transform(to:)</code></h3><p>This is straight forward: use the value directly. Typically you&rsquo;d return this.</p><p>Sometimes I used <code>transform</code> within a <code>flatMap</code> to keep the same return value. Now, just <code>try await</code> these side effects.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-	.flatMap({ user in
</span></span></span><span style=display:flex><span><span style=color:#f92672>-		user.update(on: req.db)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-			.transform(to: user)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-	})
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+	try await update(on: req.db)
</span></span></span></code></pre></div><h3 id=migrate-always_>Migrate <code>.always(_:)</code></h3><p><code>.always</code> will be executed when an <code>EventLoopFuture</code> fails and when it succeeds. This is the same behaviour of <code>defer</code> with <code>async</code>/<code>await</code>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-	return computeSomething()
</span></span></span><span style=display:flex><span><span style=color:#f92672>- .always { _ in
</span></span></span><span style=display:flex><span><span style=color:#f92672>- 	doSomething()
</span></span></span><span style=display:flex><span><span style=color:#f92672>- }
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+ defer {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		doSomething()
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+ }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	return try await computeSomething()
</span></span></span></code></pre></div><blockquote><p><em><strong>Attention:</strong> you probably need to move your defer up. Using <code>async</code>/<code>await</code> will likely introduce more return and throw statements which will exit your functions early.</em></p></blockquote><h3 id=returning-constant-futures>Returning constant futures</h3><p>If you currently throw a failing future, just throw the error directly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>- return req.eventLoop.future(error: Abort(.notFound))
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+ throw Abort(.notFound)
</span></span></span></code></pre></div><p>To replace a succeeding future, return the value directly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>- return req.eventLoop.future(success: value)
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+ return value
</span></span></span></code></pre></div><p>If thee <code>future(error:)</code> was embedded within a <code>do</code>-<code>catch</code> to lift errors to an <code>EventLoopFuture</code>, you can probably remove the <code>do</code>-<code>catch</code> and mark the function as <code>throws</code> instead.</p><h3 id=test-and-commit>Test and Commit</h3><p>Do not forget to regularly run your tests and to keep your project in a green state. From time to time, do some commits.</p><p><em><a href=https://github.com/vknabel/puffery/commit/17825477cb1d2709dc16e0669a9b943e2d978fd4><code>git commit -am "Use async/await for Vapor"</code></a></em></p><h2 id=real-world-examples>Real World Examples</h2><p>In case you need guidance, here are typical examples for Vapor-endpoints. These examples should look familiar.</p><p><em>All code snippets are actual code from Puffery.</em></p><h3 id=example-for-a-fluent-query>Example for a Fluent query</h3><p>This function is part of the <code>SubscriptionRepository</code>. It is meant to be used from <code>Controllers</code> to consistently access, filter and sort the channel subscriptions of a user.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>all</span>(of user: User) -&gt; EventLoopFuture<span style=color:#f92672>&lt;</span>[Subscription]<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>try</span> Subscription.query(on: db)
</span></span><span style=display:flex><span>			.filter(<span style=color:#960050;background-color:#1e0010>\</span>Subscription.<span style=color:#960050;background-color:#1e0010>$</span>user.<span style=color:#960050;background-color:#1e0010>$</span>id == user.requireID())
</span></span><span style=display:flex><span>			.sort(<span style=color:#960050;background-color:#1e0010>\</span>.<span style=color:#960050;background-color:#1e0010>$</span>createdAt, .descending)
</span></span><span style=display:flex><span>			.all()
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> eventLoop.future(error: error)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We start by changing the type signature to <code>async throws</code>.</p><p>To fix the type errors, we could drop <code>do</code>-<code>catch</code> as the new variant is throwing. Previously it wasn&rsquo;t throwing as there is no overload of <code>EventLoopFuture.flatMap</code> that accepts throwing <code>EventLoopFuture</code>s. Therefore <code>all(of:)</code> was required to lift thrown errors to futures.</p><p>As there is no distinction between directly throwing and a query failure with <code>async</code>/<code>await</code> we can get rid of the <code>do</code>-<code>catch</code>. And as Fluent has overloads for both <code>EventLoopFuture</code> and <code>async throws</code> we&rsquo;re done here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>all</span>(of user: User) async <span style=color:#66d9ef>throws</span> -&gt; [Subscription] {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> await Subscription.query(on: db)
</span></span><span style=display:flex><span>	  .filter(<span style=color:#960050;background-color:#1e0010>\</span>Subscription.<span style=color:#960050;background-color:#1e0010>$</span>user.<span style=color:#960050;background-color:#1e0010>$</span>id == user.requireID())
</span></span><span style=display:flex><span>    .sort(<span style=color:#960050;background-color:#1e0010>\</span>.<span style=color:#960050;background-color:#1e0010>$</span>createdAt, .descending)
</span></span><span style=display:flex><span>    .all()
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><h3 id=example-migrations-for-simple-read-only-endpoints>Example Migrations for simple read-only endpoints</h3><p>My <code>MessageController</code> looked like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MessageController</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>messagesForAllChannels</span>(<span style=color:#66d9ef>_</span> req: Request) <span style=color:#66d9ef>throws</span> -&gt; EventLoopFuture<span style=color:#f92672>&lt;</span>[MessageResponse]<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>let</span> user = <span style=color:#66d9ef>try</span> req.auth.require(User.<span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> req.subscriptions.all(of: user)
</span></span><span style=display:flex><span>	    .flatMap(req.messages.latestSubscribed(<span style=color:#66d9ef>for</span>:))
</span></span><span style=display:flex><span>      .flatMapThrowing { messages <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>	      <span style=color:#66d9ef>try</span> messages.map {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>try</span> MessageResponse($0.message, subscription: $0.subscription)
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// other endpoints ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code should be familiar to any Vapor developer. I started migration with the function signature, replaced <code>flatMap</code> and <code>flatMapThrowing</code> and inserted the <code>.get()</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>messagesForAllChannels</span>(<span style=color:#66d9ef>_</span> req: Request) async <span style=color:#66d9ef>throws</span> -&gt; [MessageResponse] {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> user = <span style=color:#66d9ef>try</span> req.auth.require(User.<span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> subs = <span style=color:#66d9ef>try</span> await req.subscriptions.all(of: user).<span style=color:#66d9ef>get</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> messages = <span style=color:#66d9ef>try</span> await req.messages.latestSubscribed(<span style=color:#66d9ef>for</span>: subs).<span style=color:#66d9ef>get</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>try</span> messages.map {
</span></span><span style=display:flex><span>	  <span style=color:#66d9ef>try</span> MessageResponse($0.message, subscription: $0.subscription)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After I migrated my <code>SubscriptionRepository</code>, I could even get rid of the trailing <code>.get()</code>.</p><h3 id=example-migration-for-simple-write-endpoints>Example Migration for simple write-endpoints</h3><p>This function&rsquo;s migration path was more complex.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>confirmEmailIfNeeded</span>(<span style=color:#66d9ef>_</span> user: User) <span style=color:#66d9ef>throws</span> -&gt; EventLoopFuture&lt;Void&gt; {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> emailAddress = user.email <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> req.eventLoop.future()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> confirmation = <span style=color:#66d9ef>try</span> Confirmation(scope: <span style=color:#e6db74>&#34;email&#34;</span>, snapshot: emailAddress, user: user)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> confirmation.create(on: req.db)
</span></span><span style=display:flex><span>		.flatMapThrowing { <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>try</span> Email(<span style=color:#75715e>/*...*/</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		.flatMap { email <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>self</span>.req.queue.dispatch(SendEmailJob.<span style=color:#66d9ef>self</span>, email)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we could completely remove the empty <code>req.eventLoop.future()</code>. A simple, blank <code>return</code> statement is enough. And creating models doesn&rsquo;t force us anymore to nest everything one level deeper. We <code>await</code> the result, but we discard it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>confirmEmailIfNeeded</span>(<span style=color:#66d9ef>_</span> user: User) async <span style=color:#66d9ef>throws</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> emailAddress = user.email <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> confirmation = <span style=color:#66d9ef>try</span> Confirmation(scope: <span style=color:#e6db74>&#34;email&#34;</span>, snapshot: emailAddress, user: user)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> await confirmation.create(on: req.db)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> email = <span style=color:#66d9ef>try</span> Email(<span style=color:#75715e>/*...*/</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> await req.queue.dispatch(SendEmailJob.<span style=color:#66d9ef>self</span>, email)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=summary>Summary</h2><p>Within this post we upgraded our Swift version, Package manifest, docker / CI Swift versions and our dependencies. Then we incrementally migrated portions of our codebase by following a set of rules. What was your migration like? Did you experience any problems?</p><p>If you wish, check out the open source repository of <a href=https://github.com/vknabel/puffery>Puffery</a> or check it out on the <a href=https://apps.apple.com/de/app/puffery/id1508776889>App Store</a>. If you have any questions or feedback don&rsquo;t hesitate to ask me on <a href=https://mastodon.social/@vknabel>@mastodon.social@vknabel</a> or join the <a href=https://github.com/vknabel/puffery/discussions>Puffery disussions</a>.</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/swift>swift</a></li><li><a href=/tags/vapor>vapor</a></li><li><a href=/tags/migration>migration</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/vknabel rel=me title=GitHub><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://mastodon.social/@vknabel/ rel=me title=Mastodon><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#at-sign"/></svg></a><a class=border></a></div><div class=footer-info>2025 © Valentin Knabel | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>