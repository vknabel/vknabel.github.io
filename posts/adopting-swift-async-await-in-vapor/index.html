<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Adopting Swift Async Await in Vapor | vknabel</title><link rel=stylesheet href=/css/main.min.e9fd179d6f16b595a4ec4953ef9042fa8e3bcdf9755535ae526ed686593a3ced.css integrity="sha256-6f0XnW8WtZWk7ElT75BC+o47zfl1VTWuUm7Whlk6PO0=" crossorigin=anonymous><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inria+Serif:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Lora:ital,wght@0,400..700;1,400..700&display=swap" rel=stylesheet><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script><link rel=icon type=image/png href=/images/vknabel.jpg><link rel=me href=https://mastodon.social/@vknabel><meta name=fediverse:creator content="@vknabel@mastodon.social"><script defer src=https://uma.knabel.dev/umami data-website-id=6c602988-83e0-47c7-a844-d7c4e6edc43d data-domains=www.vknabel.com></script><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A few months ago Swift 5.5 has been released and made async/await available. And in 4.50.0 Vapor added support for it, too!"><meta property="og:image" content><meta property="og:url" content="https://vknabel.com/posts/adopting-swift-async-await-in-vapor/"><meta property="og:site_name" content="vknabel"><meta property="og:title" content="Adopting Swift Async Await in Vapor"><meta property="og:description" content="A few months ago Swift 5.5 has been released and made async/await available. And in 4.50.0 Vapor added support for it, too!"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-15T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-15T00:00:00+00:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Tooling"><meta name=twitter:card content="summary"><meta name=twitter:title content="Adopting Swift Async Await in Vapor"><meta name=twitter:description content="A few months ago Swift 5.5 has been released and made async/await available. And in 4.50.0 Vapor added support for it, too!"><link rel=alternate type=application/rss+xml href=https://vknabel.com/index.xml title=News><link rel=alternate type=application/rss+xml href=https://vknabel.com/posts/index.xml title=Posts><link rel=alternate type=application/rss+xml href=https://vknabel.com/library/index.xml title=Library><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/announcement/index.xml title="Tagged with Announcement"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/books/index.xml title="Tagged with Books"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/go/index.xml title="Tagged with Go"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/hosting/index.xml title="Tagged with Hosting"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/lithia/index.xml title="Tagged with Lithia"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/plants/index.xml title="Tagged with Plants"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/puffery/index.xml title="Tagged with Puffery"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/swift/index.xml title="Tagged with Swift"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/tooling/index.xml title="Tagged with Tooling"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/web/index.xml title="Tagged with Web"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/zirric/index.xml title="Tagged with Zirric"></head><body><div class=content><header><nav class=menu-main><ul><li><a aria-current=true class=ancestor href=/posts/>Blog</a></li><li><a href=/library/>Library</a></li></ul></nav><a href=/ class=logo>vk</a><nav class=menu-secondary><ul><li><a href=/about/>About</a></li></ul></nav></header><main><h1>Adopting Swift Async Await in Vapor</h1><small><i>Posted on <time datetime=2021-11-15T00:00:00+00:00>2021-11-15</time></i></small><p>A few months ago Swift 5.5 has been released and made <code>async</code>/<code>await</code> available. And in <a href=https://github.com/vapor/vapor/releases/tag/4.50.0>4.50.0</a> Vapor added support for it, too!</p><blockquote><p><em>If you are still on Vapor 3, you first need to <a href=https://www.vknabel.com/pages/Upgrading-a-server-side-Swift-project-to-Vapor-4/>upgrade your server to Vapor 4</a>.</em></p></blockquote><p>Now we can migrate most usages of Swift NIO&rsquo;s <code>EventLoopFuture</code> with <code>async</code>. But we don&rsquo;t have to! This is not a breaking change. I recently performed this upgrade for the server of my app <a href=https://github.com/vknabel/puffery>Puffery</a> and as both, the client and the server are open source I will include links to the respective git commits.</p><blockquote><p><em><strong>Puffery</strong> is an app to send messages into channels using Shortcuts or HTTP. This will trigger a push notification to all clients that have subscribed. Within the app you can view your messages and channels.</em></p></blockquote><p>I wouldn&rsquo;t recommend to directly replace all occurrences of <code>EventLoopFuture</code>. If you aren&rsquo;t going to touch specific code paths in a while, there is no need to migrate those. But we&rsquo;ll come back to that later.</p><h2 id=upgrading-to-swift-55>Upgrading to Swift 5.5</h2><p>If you haven&rsquo;t already, you need to upgrade your Swift Tools Version within your <code>Package.swift</code>-manifest:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// swift-tools-version:5.5</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>PackageDescription</span>
</span></span></code></pre></div><p>Now a few lines later we need to upgrade to a newer macOS version, because <code>async</code>/<code>await</code> not only requires Swift 5.5, but also macOS 12 Monterey. Make sure you have upgraded accordingly. Otherwise you&rsquo;d need to work on a linux machine or within a docker container.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> package = Package(
</span></span><span style=display:flex><span>    name: <span style=color:#e6db74>&#34;PufferyServer&#34;</span>,
</span></span><span style=display:flex><span>    platforms: [
</span></span><span style=display:flex><span>        .macOS(.v12), <span style=color:#75715e>// upgrade to .v12</span>
</span></span><span style=display:flex><span>    ],
</span></span></code></pre></div><p>Next up, we need to bump our dependencies. As we want to rely on special features of the new Vapor, we explicitly go <code>from: "4.50.0"</code>. Repeat this with other dependencies like Fluent.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span>		<span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    dependencies: [
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>	    .package(url: <span style=color:#e6db74>&#34;https://github.com/vapor/vapor.git&#34;</span>, from: <span style=color:#e6db74>&#34;4.50.0&#34;</span>), <span style=color:#75715e>// upgrade to 4.50.0</span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>		],
</span></span></code></pre></div><p>Now, to silence a warning, we need to explicitly declare our <code>Run</code> target as <code>executableTarget</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span>    targets: [
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>	    .executableTarget(name: <span style=color:#e6db74>&#34;Run&#34;</span>, dependencies: [<span style=color:#e6db74>&#34;App&#34;</span>]),
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>		]
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>If you use a Dockerfile, build <code>FROM swift:5.5 as build</code>. Also if present don&rsquo;t forget to update your <code>.swift-version</code>-file and your CI.</p><p>Now update your packages using <code>swift package update</code>. If you use Xcode, also update your dependencies using <code>File > Packages > Update to Latest Package Versions</code> to keep them in sync. In theory <code>swift build</code> and <code>swift test</code> should run without any errors. If it does, fix those and proceed.</p><p><em><a href=https://github.com/vknabel/puffery/commit/1c41e5ae5c49748c1389b4491e03d595e5b0f406><code>git commit -am "Upgraded PufferyServer to Swift 5.5"</code></a></em></p><h2 id=adopting-async-await>Adopting Async Await</h2><p>Now that we upgraded our new Swift version and updated our dependencies, let&rsquo;s get started with our migration.</p><p>We will incrementally do tiny steps and migrate every function after another. But it doesn&rsquo;t make sense to migrate all functions immediately. If you haven&rsquo;t touched specific files in a while, there is no need to do so now. A great example are your database migrations. You won&rsquo;t touch them anyways. Just write new ones with <code>async</code>/<code>await</code> and you are fine.</p><p>In my opinion, controllers are the easiest place to get started. Later you can tackle migrate <code>Jobs</code> or <code>ScheduledJob</code>s. Then your services and your repositories.</p><p>The easiest places to upgrade will most likely be your Fluent queries: there are overloads for <code>.find()</code> and <code>.all()</code> to return <code>EventLoopFuture</code> and <code>async throws</code>.</p><h3 id=migrate-the-function-signature>Migrate the function signature</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>- 	func messagesForAllChannels(_ req: Request) throws -&gt; EventLoopFuture&lt;[MessageResponse]&gt; {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+ 	func messagesForAllChannels(_ req: Request) async throws -&gt; [MessageResponse] {
</span></span></span></code></pre></div><p>Now fix all issues within the function. Then fix the errors of all callers.</p><p>If you temporarily converted invocations of this method from <code>EventLoopFuture</code> to an async function using <code>.get()</code>, it is now time to remove it.</p><h3 id=migrate-protocol-methods-if-directly-affected>Migrate Protocol Methods if directly affected</h3><p>Most protocols need to be prefixed with <code>Async</code> like <code>AsyncJob</code> or <code>AsyncScheduledJob</code>. Then you can replace all function signatures.</p><h3 id=i-need-async-but-i-have-an-eventloopfuture>I need async, but I have an EventLoopFuture</h3><p>To convert a not yet converted <code>EventLoopFuture</code>, we call <code>EventLoopFuture&lt;V>.get() async throws -> V</code>. You can migrate the function later.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>try</span> await theEventLoopFuture.<span style=color:#66d9ef>get</span>()
</span></span></code></pre></div><h3 id=i-need-an-eventloopfuture-but-i-have-an-async-function>I need an EventLoopFuture, but I have an async function</h3><p>Sometimes I decided to keep some function signatures as they were and I did not migrate them. For those cases I created a small helper function to create an <code>EventLoopFuture</code> from an async task.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>EventLoop</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>from</span>&lt;T&gt;(task: @escaping () async <span style=color:#66d9ef>throws</span> -&gt; T) -&gt; EventLoopFuture&lt;T&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> promise = makePromise(of: T.<span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>        promise.completeWithTask { <span style=color:#66d9ef>try</span> await task() }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> promise.futureResult
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For example executing multiple futures in parallel is easy with <code>eventLoop.flatten</code>, but it&rsquo;s much harder with <code>async</code>/<code>await</code>.</p><h3 id=migrate-flatmap>Migrate <code>.flatMap</code></h3><p>Migrate <code>.flatMap({ messages in doSomething(messages) })</code> to <code>let result = try await doSomething(messages).get()</code>.</p><h3 id=migrate-flatmapthrowing>Migrate <code>.flatMapThrowing</code></h3><p>Migrate <code>.flatMapThrowing({ messages in doSomething(messages) })</code> to <code>let result = try doSomething(messages)</code></p><h3 id=migrate-eventloopflatten>Migrate <code>eventLoop.flatten</code></h3><p>Executing multiple futures in parallel is easy with <code>eventLoop.flatten</code>, but it&rsquo;s much harder with <code>async</code>/<code>await</code>.</p><p>I&rsquo;d recommend to keep this part as is, and to keep this part as <code>EventLoopFuture</code>.
See [I need an EventLoopFuture, but I have async](#I need an EventLoopFuture, but I have async).</p><h3 id=migrate-transformto>Migrate <code>.transform(to:)</code></h3><p>This is straight forward: use the value directly. Typically you&rsquo;d return this.</p><p>Sometimes I used <code>transform</code> within a <code>flatMap</code> to keep the same return value. Now, just <code>try await</code> these side effects.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-	.flatMap({ user in
</span></span></span><span style=display:flex><span><span style=color:#f92672>-		user.update(on: req.db)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-			.transform(to: user)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-	})
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	try await update(on: req.db)
</span></span></span></code></pre></div><h3 id=migrate-always_>Migrate <code>.always(_:)</code></h3><p><code>.always</code> will be executed when an <code>EventLoopFuture</code> fails and when it succeeds. This is the same behaviour of <code>defer</code> with <code>async</code>/<code>await</code>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-	return computeSomething()
</span></span></span><span style=display:flex><span><span style=color:#f92672>- .always { _ in
</span></span></span><span style=display:flex><span><span style=color:#f92672>- 	doSomething()
</span></span></span><span style=display:flex><span><span style=color:#f92672>- }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+ defer {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		doSomething()
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+ }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	return try await computeSomething()
</span></span></span></code></pre></div><blockquote><p><em><strong>Attention:</strong> you probably need to move your defer up. Using <code>async</code>/<code>await</code> will likely introduce more return and throw statements which will exit your functions early.</em></p></blockquote><h3 id=returning-constant-futures>Returning constant futures</h3><p>If you currently throw a failing future, just throw the error directly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>- return req.eventLoop.future(error: Abort(.notFound))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+ throw Abort(.notFound)
</span></span></span></code></pre></div><p>To replace a succeeding future, return the value directly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>- return req.eventLoop.future(success: value)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+ return value
</span></span></span></code></pre></div><p>If thee <code>future(error:)</code> was embedded within a <code>do</code>-<code>catch</code> to lift errors to an <code>EventLoopFuture</code>, you can probably remove the <code>do</code>-<code>catch</code> and mark the function as <code>throws</code> instead.</p><h3 id=test-and-commit>Test and Commit</h3><p>Do not forget to regularly run your tests and to keep your project in a green state. From time to time, do some commits.</p><p><em><a href=https://github.com/vknabel/puffery/commit/17825477cb1d2709dc16e0669a9b943e2d978fd4><code>git commit -am "Use async/await for Vapor"</code></a></em></p><h2 id=real-world-examples>Real World Examples</h2><p>In case you need guidance, here are typical examples for Vapor-endpoints. These examples should look familiar.</p><p><em>All code snippets are actual code from Puffery.</em></p><h3 id=example-for-a-fluent-query>Example for a Fluent query</h3><p>This function is part of the <code>SubscriptionRepository</code>. It is meant to be used from <code>Controllers</code> to consistently access, filter and sort the channel subscriptions of a user.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>all</span>(of user: User) -&gt; EventLoopFuture<span style=color:#f92672>&lt;</span>[Subscription]<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>try</span> Subscription.query(on: db)
</span></span><span style=display:flex><span>			.filter(<span style=color:#960050;background-color:#1e0010>\</span>Subscription.<span style=color:#960050;background-color:#1e0010>$</span>user.<span style=color:#960050;background-color:#1e0010>$</span>id == user.requireID())
</span></span><span style=display:flex><span>			.sort(<span style=color:#960050;background-color:#1e0010>\</span>.<span style=color:#960050;background-color:#1e0010>$</span>createdAt, .descending)
</span></span><span style=display:flex><span>			.all()
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> eventLoop.future(error: error)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We start by changing the type signature to <code>async throws</code>.</p><p>To fix the type errors, we could drop <code>do</code>-<code>catch</code> as the new variant is throwing. Previously it wasn&rsquo;t throwing as there is no overload of <code>EventLoopFuture.flatMap</code> that accepts throwing <code>EventLoopFuture</code>s. Therefore <code>all(of:)</code> was required to lift thrown errors to futures.</p><p>As there is no distinction between directly throwing and a query failure with <code>async</code>/<code>await</code> we can get rid of the <code>do</code>-<code>catch</code>. And as Fluent has overloads for both <code>EventLoopFuture</code> and <code>async throws</code> we&rsquo;re done here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>all</span>(of user: User) async <span style=color:#66d9ef>throws</span> -&gt; [Subscription] {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> await Subscription.query(on: db)
</span></span><span style=display:flex><span>	  .filter(<span style=color:#960050;background-color:#1e0010>\</span>Subscription.<span style=color:#960050;background-color:#1e0010>$</span>user.<span style=color:#960050;background-color:#1e0010>$</span>id == user.requireID())
</span></span><span style=display:flex><span>    .sort(<span style=color:#960050;background-color:#1e0010>\</span>.<span style=color:#960050;background-color:#1e0010>$</span>createdAt, .descending)
</span></span><span style=display:flex><span>    .all()
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><h3 id=example-migrations-for-simple-read-only-endpoints>Example Migrations for simple read-only endpoints</h3><p>My <code>MessageController</code> looked like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MessageController</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>messagesForAllChannels</span>(<span style=color:#66d9ef>_</span> req: Request) <span style=color:#66d9ef>throws</span> -&gt; EventLoopFuture<span style=color:#f92672>&lt;</span>[MessageResponse]<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>let</span> user = <span style=color:#66d9ef>try</span> req.auth.require(User.<span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> req.subscriptions.all(of: user)
</span></span><span style=display:flex><span>	    .flatMap(req.messages.latestSubscribed(<span style=color:#66d9ef>for</span>:))
</span></span><span style=display:flex><span>      .flatMapThrowing { messages <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>	      <span style=color:#66d9ef>try</span> messages.map {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>try</span> MessageResponse($0.message, subscription: $0.subscription)
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// other endpoints ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code should be familiar to any Vapor developer. I started migration with the function signature, replaced <code>flatMap</code> and <code>flatMapThrowing</code> and inserted the <code>.get()</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>messagesForAllChannels</span>(<span style=color:#66d9ef>_</span> req: Request) async <span style=color:#66d9ef>throws</span> -&gt; [MessageResponse] {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> user = <span style=color:#66d9ef>try</span> req.auth.require(User.<span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> subs = <span style=color:#66d9ef>try</span> await req.subscriptions.all(of: user).<span style=color:#66d9ef>get</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> messages = <span style=color:#66d9ef>try</span> await req.messages.latestSubscribed(<span style=color:#66d9ef>for</span>: subs).<span style=color:#66d9ef>get</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>try</span> messages.map {
</span></span><span style=display:flex><span>	  <span style=color:#66d9ef>try</span> MessageResponse($0.message, subscription: $0.subscription)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After I migrated my <code>SubscriptionRepository</code>, I could even get rid of the trailing <code>.get()</code>.</p><h3 id=example-migration-for-simple-write-endpoints>Example Migration for simple write-endpoints</h3><p>This function&rsquo;s migration path was more complex.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>confirmEmailIfNeeded</span>(<span style=color:#66d9ef>_</span> user: User) <span style=color:#66d9ef>throws</span> -&gt; EventLoopFuture&lt;Void&gt; {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> emailAddress = user.email <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> req.eventLoop.future()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> confirmation = <span style=color:#66d9ef>try</span> Confirmation(scope: <span style=color:#e6db74>&#34;email&#34;</span>, snapshot: emailAddress, user: user)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> confirmation.create(on: req.db)
</span></span><span style=display:flex><span>		.flatMapThrowing { <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>try</span> Email(<span style=color:#75715e>/*...*/</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		.flatMap { email <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>self</span>.req.queue.dispatch(SendEmailJob.<span style=color:#66d9ef>self</span>, email)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we could completely remove the empty <code>req.eventLoop.future()</code>. A simple, blank <code>return</code> statement is enough. And creating models doesn&rsquo;t force us anymore to nest everything one level deeper. We <code>await</code> the result, but we discard it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>confirmEmailIfNeeded</span>(<span style=color:#66d9ef>_</span> user: User) async <span style=color:#66d9ef>throws</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> emailAddress = user.email <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> confirmation = <span style=color:#66d9ef>try</span> Confirmation(scope: <span style=color:#e6db74>&#34;email&#34;</span>, snapshot: emailAddress, user: user)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> await confirmation.create(on: req.db)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> email = <span style=color:#66d9ef>try</span> Email(<span style=color:#75715e>/*...*/</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> await req.queue.dispatch(SendEmailJob.<span style=color:#66d9ef>self</span>, email)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=summary>Summary</h2><p>Within this post we upgraded our Swift version, Package manifest, docker / CI Swift versions and our dependencies. Then we incrementally migrated portions of our codebase by following a set of rules. What was your migration like? Did you experience any problems?</p><p>If you wish, check out the open source repository of <a href=https://github.com/vknabel/puffery>Puffery</a> or check it out on the <a href=https://apps.apple.com/de/app/puffery/id1508776889>App Store</a>. If you have any questions or feedback don&rsquo;t hesitate to ask me on <a href=https://mastodon.social/@vknabel>@mastodon.social@vknabel</a> or join the <a href=https://github.com/vknabel/puffery/discussions>Puffery disussions</a>.</p><ul class=tags><li class="tags-item tags-item--tag"><a href=/tags/swift/>Swift</a></li><li class="tags-item tags-item--tag"><a href=/tags/tooling/>Tooling</a></li></div></main><footer><div><small>2026 © Valentin Knabel</small><br><small>Made with ♥ by a human.</small><br></div><div><h6 id=menu-social>Social</h6><nav class=menu-social><ul><li><a href=https://github.com/vknabel>GitHub</a></li><li><a href=https://mastodon.social/@vknabel/>Mastodon</a></li><li><a href=https://code.knabel.dev/explore/repos>code.knabel.dev</a></li><li><a href=/rss/>RSS</a></li></ul></nav></div><div><h6 id=menu-links>Links</h6><nav class=menu-tertiary><ul><li><a href=/now/>Now</a></li><li><a href=/colophon/>Colophon</a></li><li><a href=/projects/>Projects</a></li><li><a href=/sovereignity/>Sovereignity</a></li><li><a href=/tags/>Tags</a></li></ul></nav></div></footer></div></body></html>