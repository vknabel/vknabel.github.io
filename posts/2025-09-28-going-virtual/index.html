<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Zirric: Going Virtual | vknabel</title><link rel=stylesheet href=/css/main.min.e9fd179d6f16b595a4ec4953ef9042fa8e3bcdf9755535ae526ed686593a3ced.css integrity="sha256-6f0XnW8WtZWk7ElT75BC+o47zfl1VTWuUm7Whlk6PO0=" crossorigin=anonymous><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inria+Serif:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Lora:ital,wght@0,400..700;1,400..700&display=swap" rel=stylesheet><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script><link rel=icon type=image/png href=/images/vknabel.jpg><link rel=me href=https://mastodon.social/@vknabel><meta name=fediverse:creator content="@vknabel@mastodon.social"><script defer src=https://uma.knabel.dev/umami data-website-id=6c602988-83e0-47c7-a844-d7c4e6edc43d data-domains=www.vknabel.com></script><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A few years ago while I started working on Lithia, I decided to use whatever takes me to my goal. Getting finished was the primary focus. And I did."><meta property="og:image" content><meta property="og:url" content="https://vknabel.com/posts/2025-09-28-going-virtual/"><meta property="og:site_name" content="vknabel"><meta property="og:title" content="Zirric: Going Virtual"><meta property="og:description" content="A few years ago while I started working on Lithia, I decided to use whatever takes me to my goal. Getting finished was the primary focus. And I did."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-28T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-28T00:00:00+00:00"><meta property="article:tag" content="Zirric"><meta property="article:tag" content="Tooling"><meta property="article:tag" content="Go"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zirric: Going Virtual"><meta name=twitter:description content="A few years ago while I started working on Lithia, I decided to use whatever takes me to my goal. Getting finished was the primary focus. And I did."><link rel=alternate type=application/rss+xml href=https://vknabel.com/index.xml title=News><link rel=alternate type=application/rss+xml href=https://vknabel.com/posts/index.xml title=Posts><link rel=alternate type=application/rss+xml href=https://vknabel.com/library/index.xml title=Library><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/announcement/index.xml title="Tagged with Announcement"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/books/index.xml title="Tagged with Books"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/go/index.xml title="Tagged with Go"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/hosting/index.xml title="Tagged with Hosting"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/lithia/index.xml title="Tagged with Lithia"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/plants/index.xml title="Tagged with Plants"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/puffery/index.xml title="Tagged with Puffery"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/swift/index.xml title="Tagged with Swift"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/tooling/index.xml title="Tagged with Tooling"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/web/index.xml title="Tagged with Web"><link rel=alternate type=application/rss+xml href=https://vknabel.com/tags/zirric/index.xml title="Tagged with Zirric"></head><body><div class=content><header><nav class=menu-main><ul><li><a aria-current=true class=ancestor href=/posts/>Blog</a></li><li><a href=/library/>Library</a></li></ul></nav><a href=/ class=logo>vk</a><nav class=menu-secondary><ul><li><a href=/about/>About</a></li></ul></nav></header><main><h1>Zirric: Going Virtual</h1><small><i>Posted on <time datetime=2025-09-28T00:00:00+00:00>2025-09-28</time></i></small><p>A few years ago while I started working on <a href=https://code.knabel.dev/lithia-lang/lithia>Lithia</a>, I decided to use whatever takes me to my goal. Getting finished was the primary focus. And I did.</p><p>With <a href=https://code.knabel.dev/zirric-lang/zirric>Zirric</a> I want to take less compromise and build a better language. Performance and portability aren&rsquo;t completely irrelevant anymore.</p><p><em>This blog post is part of a <a href=/posts/journey-about-creating-a-new-programming-language/>Journey about creating a new programming language</a>.</em></p><h2 id=the-tree-walker>The Tree Walker</h2><p>For Lithia I chose to implement a tree walker interpreter. It is simple to implement and easy to understand. The downside is that it&rsquo;s slow.</p><p>Here the interpreter walks the abstract syntax tree (AST) and executes the program directly. This means that every time a function is called, the AST nodes for that function have to be traversed again.</p><p>In this approach every node in the AST has an <code>evaluate</code> method that takes the current context as a parameter. The context holds variable bindings and other state information.</p><p>Variables and constants were stored in a map. During every variable access, a lookup with the string name of the variable had to be performed. In case of a miss, a parent context had to be checked as well until the variable was found or the global context was reached.</p><pre tabindex=0><code class=language-lithia data-lang=lithia>let a = &#34;global&#34;

func do { =&gt;
  let b = &#34;local&#34;

  print a // lookup &#34;a&#34; in current context -&gt; miss -&gt; lookup &#34;a&#34; in parent context -&gt; hit
  print b // lookup &#34;b&#34; in current context -&gt; hit
}

do // looks up the function &#34;do&#34; and calls it
</code></pre><p>Additionally checking the type of a value wasn&rsquo;t trivial as well as the types had to be looked up by name as well.</p><p>Furthermore Lithia leverages lazy evaluation, which means that expressions are not evaluated until their value is needed. This adds additional overhead as every expression has to be wrapped in a thunk (a parameterless function).</p><p>And this makes the second problem of this clear: everything is hidden behind pointers and in general everything is kind of costly. Not necessarily in terms of complexity, its just slow like hashing strings multiple times per variable access, checking if everything has been evaluated and last but not least it can&rsquo;t be cached efficiently by the CPU.</p><h2 id=the-bytecode-interpreter>The Bytecode Interpreter</h2><p>Zirric takes a different approach to this. It defines a virtual machine (VM) that executes bytecode instructions. Zirric&rsquo;s VM is stack based, which is comparable for a simple calculator or a deck of cards: each operation works on the topmost elements of the stack.</p><p>The bytecode itself is separated of all constants. Instead these are in a separate array or slice while the bytecode references them by index.
In case of the expression <code>40 + 2</code>, the constant <code>40</code> is at index <code>0</code> and <code>2</code> is at index <code>1</code>. The human readable bytecode to add these two numbers is then:</p><pre tabindex=0><code># 1 + 2
Cons 0 # Pushes the constant at index 0 (40) onto the stack
Cons 1 # Pushes the constant at index 1 (2) onto the stack
Add
# Result: 42
</code></pre><blockquote><p>The actual bytecode currently looks like this: <code>01 00 00 01 00 01 10</code>. Neat, huh?</p></blockquote><p>The VM iterates over the bytecode instructions and executes them one by one.
Here <code>Cons</code> loads the constant with the fitting index onto the stack. <code>Add</code> pops the top two elements from the stack, adds them and pushes the result back onto the stack.
That way the stack of the VM grows and shrinks as needed.</p><p>When it comes to variables, the VM uses a different approach as well: each variable gets an index assigned at compile time. That way variable access is just a matter of looking up an index of a single array.</p><p>Now let&rsquo;s get back to our example from above:</p><pre tabindex=0><code class=language-lithia data-lang=lithia>let a = &#34;global&#34; // globals[0] = constants[0]

func do() { // functions are constants: constants[1]
  let b = &#34;local&#34; // locals[0] = constants[2]

  print(a) // globals[0]
  print(b) // locals[0]
}

do() // constants[1]()
</code></pre><p>No more string lookups. No more parent contexts. Just direct index access.
And the best part of this: the CPU can cache this data much more efficiently.</p><p>What about laziness? Almost everything is now eagerly evaluated. Expressions are evaluated as soon as they are encountered.
Though there are a few exceptions like logical operators (<code>&&</code>, <code>||</code>) which skip their right hand side if the result is already determined by the left hand side. This is common and does not add much overhead.</p><p>But in Zirric globals are still initialized lazily. More on this in a future blog post.</p><h2 id=why-that-hassle>Why that hassle?</h2><p>Interpreters are much easier to implement and to understand. Is this actually worth it?</p><p>Glad you asked! I made some micro benchmarks for Lithia and Zirric. In this case I wrote a simple recursive Fibonacci function in both languages and measured the time it takes to compute for several numbers.</p><blockquote><p>Microbenchmarks can be misleading and do not reflect real world performance. But as long as we keep all tests as similar as possible, we can get a rough idea of the performance difference.</p></blockquote><p>Here is the Lithia version:</p><pre tabindex=0><code class=language-lithia data-lang=lithia>func fib { n =&gt;
    if (n &lt; 2), n, (fib n - 1) + (fib n - 2)
}
</code></pre><p>Here is the Zirric version:</p><pre tabindex=0><code class=language-zirric data-lang=zirric>func fib(n) {
	return if n &lt; 2 {
		n
	} else {
		fib(n-1) + fib(n-2)				
	}
}
</code></pre><p>As both languages are implemented in Go, I used the builtin Go benchmarking for both to keep it as similar as possible.</p><p>And these are the results on my machine:</p><table><thead><tr><th>Input</th><th>Repetitions</th><th>Lithia</th><th>Repetitions</th><th>Zirric</th><th>Factor</th></tr></thead><tbody><tr><td>28</td><td>1</td><td>5,338 sec</td><td>1,000,000,000</td><td>0.1101 ns</td><td>4,848,486</td></tr><tr><td>30</td><td>1</td><td>13,990 sec</td><td>1,000,000,000</td><td>0.2860 ns</td><td>4,891,832</td></tr><tr><td>32</td><td>1</td><td>36,805 sec</td><td>1,000,000,000</td><td>0.7305 ns</td><td>5,038,386</td></tr><tr><td>40</td><td>0</td><td>(too long)</td><td>1</td><td>34,238 sec</td><td>(too long)</td></tr></tbody></table><p>When I first saw these results, I had to check if I messed something up. We are comparing seconds with nanoseconds here. That&rsquo;s why I added another run with <code>fib(40)</code> for Zirric to validate the tests. And they were right. Zirric is nearly <em>five million</em> times faster than Lithia in this case.</p><p>To get some more context, I also measured the Python and Ruby <code>fib(40)</code> and got around 10 to 17 seconds here. Although these numbers are not accurate and probably estimated too high, they give a rough idea of the performance difference. Zirric is multiple times slower than these languages, but still in the same ballpark, while Lithia is outclassed by magnitudes.</p><p>Zirric is still in early development. Through optimization, new language features but also additional safe guards the performance profile will change over time. And probably not always for the better. Also this is just a microbenchmark that is not in favor of Lithia. Real world performance might be different. Take these numbers with a grain of salt.</p><p>But yes, this was worth the hassle.
In case you are curios about what&rsquo;s up next or want a nerd talk, feel free to reach out to me <a href=https://mastodon.social/@vknabel>@mastodon.social@vknabel</a>.</p><ul class=tags><li class="tags-item tags-item--tag"><a href=/tags/zirric/>Zirric</a></li><li class="tags-item tags-item--tag"><a href=/tags/tooling/>Tooling</a></li><li class="tags-item tags-item--tag"><a href=/tags/go/>Go</a></li></div></main><footer><div><small>2026 © Valentin Knabel</small><br><small>Made with ♥ by a human.</small><br></div><div><h6 id=menu-social>Social</h6><nav class=menu-social><ul><li><a href=https://github.com/vknabel>GitHub</a></li><li><a href=https://mastodon.social/@vknabel/>Mastodon</a></li><li><a href=https://code.knabel.dev/explore/repos>code.knabel.dev</a></li><li><a href=/rss/>RSS</a></li></ul></nav></div><div><h6 id=menu-links>Links</h6><nav class=menu-tertiary><ul><li><a href=/now/>Now</a></li><li><a href=/colophon/>Colophon</a></li><li><a href=/projects/>Projects</a></li><li><a href=/sovereignity/>Sovereignity</a></li><li><a href=/tags/>Tags</a></li></ul></nav></div></footer></div></body></html>